<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fill-in-the-Blank Exercises - AfroLingua</title>
    <link rel="stylesheet" href="/AI/styles/fillBlank.css" />
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
      .difficulty-display {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 5px 10px;
        background-color: #f0f0f0;
        border-radius: 3px;
      }
      .timer-display {
        margin-top: 10px;
        text-align: center;
      }
      .progress-container {
        width: 100%;
        max-width: 600px;
        margin: 20px auto;
        background-color: #e0e0e0;
        border-radius: 5px;
        overflow: hidden;
      }
      .progress-bar {
        height: 20px;
        width: 0%;
        background: linear-gradient(to right, #000000, #ffd700);
        transition: width 0.5s ease-in-out;
      }
      .progress-label {
        text-align: center;
        margin-top: 5px;
        font-size: 14px;
        color: #333;
      }
      .level-up-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: #ffd700;
        padding: 20px;
        border-radius: 10px;
        font-size: 24px;
        text-align: center;
        z-index: 2000;
        display: none;
      }
      .fib-container {
        position: relative;
        display: inline-block;
      }
      .fib-input {
        margin-right: 5px;
      }
      .checkmark {
        display: none;
        color: green;
        font-size: 20px;
        position: absolute;
        right: -25px;
        top: 50%;
        transform: translateY(-50%);
      }
      .translation-text {
        display: none;
        color: #155724;
        margin-top: 5px;
      }
      .circular-progress {
        display: none;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #ffd700;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 10px auto;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <div class="chat-container">
      <h1><span id="selectedLanguage"></span> Exercises</h1>
      <div class="difficulty-display" id="difficultyDisplay">Difficulty: Easy (1/15)</div>
      <div id="chatArea" class="chat-area"></div>
      <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      <p class="progress-label" id="progressLabel">Progress to Next Level: 0%</p>
      <div class="input-area">
        <button id="generateButton">Generate Exercise</button>
      </div>
      <div id="loadingIndicator" class="circular-progress"></div>
      <p class="timer-display" id="timerDisplay">Interaction Time: 0s</p>
      <div class="level-up-message" id="levelUpMessage"></div>
    </div>

    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyAgUoo-ZcYNoWJbtAbjhnsh7ZKy_PXl4oU",
        authDomain: "afrolingua-ff97d.firebaseapp.com",
        projectId: "afrolingua-ff97d",
        storageBucket: "afrolingua-ff97d.appspot.com",
        messagingSenderId: "935074229602",
        appId: "1:935074229602:web:d795d5cf58c7696a6dd03b",
      };

      firebase.initializeApp(firebaseConfig);
      const auth = firebase.auth();
      const db = firebase.firestore();

      // Elements
      const chatArea = document.getElementById("chatArea");
      const generateButton = document.getElementById("generateButton");
      const selectedLanguageElement = document.getElementById("selectedLanguage");
      const difficultyDisplay = document.getElementById("difficultyDisplay");
      const timerDisplay = document.getElementById("timerDisplay");
      const progressBar = document.getElementById("progressBar");
      const progressLabel = document.getElementById("progressLabel");
      const levelUpMessage = document.getElementById("levelUpMessage");
      const loadingIndicator = document.getElementById("loadingIndicator");

      // State
      let selectedLanguage = "Default";
      let messages = [];
      let startTime = null;
      let interactionTime = 0;
      let languageTimeSpent = 0;
      let difficultyLevel = 1;
      let answeredCorrectly = 0;
      let answeredIncorrectly = 0;
      const difficultyNames = [
        "Easy", "Beginner", "Elementary", "Pre-Intermediate", "Intermediate",
        "Upper-Intermediate", "Advanced", "Proficient", "Expert", "Master",
        "Specialist", "Elite", "Legendary", "Epic", "Extreme"
      ];
      const difficultyThresholds = [
        1800, 2700, 3600, 5400, 7200, 9000, 10800, 12600, 14400, 16200,
        18000, 19800, 21600, 23400
      ];
      const positiveMessages = [
        "Great job! You've mastered another level!",
        "Congratulations! Your skills are soaring!",
        "Well done! You're a language champion!",
        "Awesome progress! Keep shining!",
        "Level up! You're unstoppable!"
      ];

      async function getUserData() {
        const user = await new Promise((resolve) => {
          auth.onAuthStateChanged((user) => resolve(user));
        });

        if (user) {
          const userDoc = await db.collection("users").doc(user.uid).get();
          selectedLanguage = userDoc.exists ? (userDoc.data().selectedLanguage || "Default") : "Default";

          const fillBlankDoc = await db.collection("fillBlank").doc(`${user.uid}_${selectedLanguage}`).get();
          if (fillBlankDoc.exists) {
            languageTimeSpent = fillBlankDoc.data().languageTimeSpent || 0;
            difficultyLevel = fillBlankDoc.data().difficulty || 1;
            answeredCorrectly = fillBlankDoc.data().answered_correctly || 0;
            answeredIncorrectly = fillBlankDoc.data().answered_incorrectly || 0;
          } else {
            languageTimeSpent = 0;
            difficultyLevel = 1;
            answeredCorrectly = 0;
            answeredIncorrectly = 0;
          }

          selectedLanguageElement.textContent = selectedLanguage;
          updateDifficultyDisplay();
          updateProgressBar();
          return user.uid;
        }
        return null;
      }

      async function updateFirestoreTimeAndAnswers(userId, timeSpent, correctDelta = 0, incorrectDelta = 0) {
        if (!userId) return;

        const previousDifficulty = difficultyLevel;
        languageTimeSpent += timeSpent;
        answeredCorrectly += correctDelta;
        answeredIncorrectly += incorrectDelta;

        let newDifficulty = 1;
        for (let i = 0; i < difficultyThresholds.length; i++) {
          if (languageTimeSpent >= difficultyThresholds[i]) {
            newDifficulty = i + 2;
          } else {
            break;
          }
        }
        difficultyLevel = Math.min(15, newDifficulty);

        await db.collection("fillBlank").doc(`${userId}_${selectedLanguage}`).set({
          userId: userId,
          language: selectedLanguage,
          languageTimeSpent: languageTimeSpent,
          difficulty: difficultyLevel,
          answered_correctly: answeredCorrectly,
          answered_incorrectly: answeredIncorrectly,
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });

        updateDifficultyDisplay();
        updateProgressBar();

        if (difficultyLevel > previousDifficulty && difficultyLevel <= 15) {
          showLevelUpCelebration();
        }
      }

      function updateDifficultyDisplay() {
        difficultyDisplay.textContent = `Difficulty: ${difficultyNames[difficultyLevel - 1]} (${difficultyLevel}/15)`;
      }

      function updateProgressBar() {
        const currentThreshold = difficultyLevel === 1 ? 0 : difficultyThresholds[difficultyLevel - 2];
        const nextThreshold = difficultyLevel === 15 ? difficultyThresholds[difficultyThresholds.length - 1] : difficultyThresholds[difficultyLevel - 1];
        const progressRange = nextThreshold - currentThreshold;
        const progressMade = languageTimeSpent - currentThreshold;
        const progressPercentage = Math.min(100, Math.max(0, (progressMade / progressRange) * 100));

        progressBar.style.width = `${progressPercentage}%`;
        progressLabel.textContent = `Progress to ${difficultyNames[difficultyLevel]}: ${Math.round(progressPercentage)}%`;
      }

      function showLevelUpCelebration() {
        confetti({
          particleCount: 100,
          spread: 70,
          origin: { y: 0.6 },
          colors: ['#000000', '#ffd700']
        });

        const randomMessage = positiveMessages[Math.floor(Math.random() * positiveMessages.length)];
        levelUpMessage.textContent = `${randomMessage} Now at ${difficultyNames[difficultyLevel - 1]}!`;
        levelUpMessage.style.display = 'block';

        setTimeout(() => {
          levelUpMessage.style.display = 'none';
        }, 3000);
      }

      function startTimer() {
        if (!startTime) {
          startTime = Date.now();
          updateTimer();
        }
      }

      function updateTimer() {
        if (startTime) {
          interactionTime = Math.floor((Date.now() - startTime) / 1000);
          timerDisplay.textContent = `Interaction Time: ${interactionTime}s`;
          requestAnimationFrame(updateTimer);
        }
      }

      function resetTimer() {
        const elapsed = interactionTime;
        startTime = Date.now();
        return elapsed;
      }

      async function fetchExercise() {
        loadingIndicator.style.display = "block"; // Show indicator
        const maxAttempts = 3; // Retry up to 3 times
        let attempt = 0;

        while (attempt < maxAttempts) {
          try {
            const response = await fetch("http://localhost:5000/generateExercise", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ 
                language: selectedLanguage,
                difficulty: difficultyLevel 
              }),
            });

            if (!response.ok) {
              const result = await response.json();
              throw new Error(result.error || `HTTP error! Status: ${response.status}`);
            }

            const result = await response.json();
            if (!result.success) throw new Error(result.error || "Unknown error from server");

            const content = result.data.trim();
            if (content.includes("Fill-in-the-Blank")) {
              const fibMatch = content.match(/Fill-in-the-Blank:\s*(.+)/);
              const fibAnswerMatch = content.match(/Answer:\s*(.+)/);
              return {
                type: "fillInTheBlank",
                sentence: fibMatch ? fibMatch[1] : "Error loading exercise.",
                answer: fibAnswerMatch ? fibAnswerMatch[1] : "N/A",
                userAnswer: null,
                isCorrect: null
              };
            } else {
              const mcMatch = content.match(/Multiple-Choice:\s*(.+)/);
              const optionsMatch = content.match(/Options:\s*(.+)/);
              const mcAnswerMatch = content.match(/Correct:\s*(.+)/);
              return {
                type: "multipleChoice",
                question: mcMatch ? mcMatch[1] : "Error loading exercise.",
                options: optionsMatch ? optionsMatch[1].split(", ") : [],
                answer: mcAnswerMatch ? mcAnswerMatch[1] : "N/A",
                userAnswer: null,
                isCorrect: null
              };
            }
          } catch (error) {
            console.error(`Fetch attempt ${attempt + 1} failed: ${error.message}`);
            attempt++;
            if (attempt === maxAttempts) {
              // After max attempts, return a placeholder instead of failing immediately
              return {
                type: "fillInTheBlank",
                sentence: "Loading exercise... Please wait.",
                answer: "N/A",
                userAnswer: null,
                isCorrect: null
              };
            }
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds before retry
          } finally {
            // Only hide indicator on success or final failure
            if (attempt === maxAttempts || attempt === 0) {
              loadingIndicator.style.display = "none";
            }
          }
        }
      }

      async function generateExercise() {
        if (!startTime) startTimer();

        const timeSpent = resetTimer();
        await updateFirestoreTimeAndAnswers(userId, timeSpent);

        const exercise = await fetchExercise();
        messages.push({ role: "ai", content: exercise });
        renderChat();

        const lastMessage = chatArea.lastElementChild;
        if (exercise.type === "fillInTheBlank") {
          const fibInput = lastMessage.querySelector(".fib-input");
          fibInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              checkFillInTheBlank(fibInput, exercise.answer, exercise.sentence, messages.length - 1);
            }
          });
        } else if (exercise.type === "multipleChoice") {
          const mcForm = lastMessage.querySelector(".mc-form");
          mcForm.addEventListener("submit", (e) => {
            e.preventDefault();
            const selectedOption = mcForm.querySelector("input[name='mc-option']:checked");
            if (selectedOption) {
              checkMultipleChoice(selectedOption, exercise.answer, messages.length - 1);
            }
          });
        }
      }

      function renderChat() {
        chatArea.innerHTML = "";
        messages.forEach((msg, index) => {
          const messageDiv = document.createElement("div");
          messageDiv.className = `message ${msg.role}`;
          if (msg.role === "ai") {
            if (msg.content.type === "fillInTheBlank") {
              const answered = msg.content.userAnswer !== null;
              const isCorrect = msg.content.isCorrect;
              const translationMatch = msg.content.sentence.match(/\((.+)\)$/);
              const translation = translationMatch ? translationMatch[1] : "Translation not available";
              messageDiv.innerHTML = `
                <p><strong>Fill-in-the-Blank:</strong> ${msg.content.sentence}</p>
                <div class="fib-container">
                  <input type="text" class="fib-input" placeholder="Type your answer" 
                    value="${msg.content.userAnswer || ''}" 
                    ${answered ? 'disabled' : ''} 
                    style="background-color: ${answered ? (isCorrect ? '#d4edda' : '#f8d7da') : ''}">
                  <span class="checkmark" style="display: ${answered && isCorrect ? 'inline' : 'none'}">✔</span>
                </div>
                <p class="translation-text" style="display: ${answered && isCorrect ? 'block' : 'none'}">${translation}</p>
                ${answered && !isCorrect ? `<p style="color: #721c24">Incorrect. Answer: ${msg.content.answer}</p>` : ''}
              `;
            } else if (msg.content.type === "multipleChoice") {
              const answered = msg.content.userAnswer !== null;
              const isCorrect = msg.content.isCorrect;
              messageDiv.innerHTML = `
                <p><strong>Multiple-Choice:</strong> ${msg.content.question}</p>
                <form class="mc-form">
                  ${msg.content.options.map((opt) => `
                    <label><input type="radio" name="mc-option" value="${opt[0]}" 
                      ${answered && msg.content.userAnswer === opt[0] ? 'checked' : ''} 
                      ${answered ? 'disabled' : ''} 
                      style="background-color: ${answered && msg.content.userAnswer === opt[0] ? (isCorrect ? '#d4edda' : '#f8d7da') : ''}"> ${opt}</label>
                  `).join("<br>")}
                  <button type="submit" class="submit-btn" ${answered ? 'disabled' : ''}>Submit</button>
                  ${answered ? `<p style="color: ${isCorrect ? '#155724' : '#721c24'}">${isCorrect ? 'Correct!' : `Incorrect. Answer: ${msg.content.answer}`}</p>` : ''}
                </form>
              `;
            } else {
              messageDiv.innerHTML = `<p>${msg.content.sentence}</p>`;
            }
          }
          chatArea.appendChild(messageDiv);
        });
        chatArea.scrollTop = chatArea.scrollHeight;
      }

      async function checkFillInTheBlank(input, correctAnswer, sentence, index) {
        const userAnswer = input.value.trim().toLowerCase();
        const isCorrect = userAnswer === correctAnswer.toLowerCase();

        messages[index].content.userAnswer = userAnswer;
        messages[index].content.isCorrect = isCorrect;

        input.disabled = true;
        input.style.backgroundColor = isCorrect ? "#d4edda" : "#f8d7da";

        const container = input.parentElement;
        const checkmark = container.querySelector(".checkmark");
        const translationText = container.parentElement.querySelector(".translation-text");

        if (isCorrect) {
          checkmark.style.display = "inline";
          const translationMatch = sentence.match(/\((.+)\)$/);
          translationText.textContent = translationMatch ? translationMatch[1] : "Translation not available";
          translationText.style.display = "block";
          await updateFirestoreTimeAndAnswers(userId, 0, 1, 0);
        } else {
          const feedback = document.createElement("p");
          feedback.textContent = `Incorrect. Answer: ${correctAnswer}`;
          feedback.style.color = "#721c24";
          container.parentElement.appendChild(feedback);
          await updateFirestoreTimeAndAnswers(userId, 0, 0, 1);
        }
      }

      async function checkMultipleChoice(radio, correctAnswer, index) {
        const userAnswer = radio.value.toLowerCase();
        const isCorrect = userAnswer === correctAnswer.toLowerCase();

        messages[index].content.userAnswer = userAnswer;
        messages[index].content.isCorrect = isCorrect;

        radio.parentElement.style.backgroundColor = isCorrect ? "#d4edda" : "#f8d7da";
        const radios = radio.form.querySelectorAll("input[type='radio']");
        radios.forEach((r) => (r.disabled = true));
        const submitBtn = radio.form.querySelector(".submit-btn");
        submitBtn.disabled = true;
        const feedback = document.createElement("p");
        feedback.textContent = isCorrect ? "Correct!" : `Incorrect. Answer: ${correctAnswer}`;
        feedback.style.color = isCorrect ? "#155724" : "#721c24";
        radio.form.appendChild(feedback);

        await updateFirestoreTimeAndAnswers(userId, 0, isCorrect ? 1 : 0, isCorrect ? 0 : 1);
      }

      let userId;
      getUserData().then((uid) => {
        userId = uid;
        generateButton.addEventListener("click", generateExercise);
      }).catch((error) => {
        console.error("Initialization failed:", error);
      });

      window.addEventListener("beforeunload", async () => {
        if (startTime && userId) {
          const totalTime = Math.floor((Date.now() - startTime) / 1000);
          await updateFirestoreTimeAndAnswers(userId, totalTime);
        }
      });
    </script>
  </body>
</html>